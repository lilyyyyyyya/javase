# 多线程

- 程序重点：高性能高并发高可用-----难点

- 多线程前提：多任务

- 实现了Runnable接口，就具备了多线程的能力（Thread）

- 两种方式

  - 继承Thread类，重写run方法，使用start开启
  - 实现Runnable接口，重写run方法，通过new thread得到thread对象，调用start方法

- start方法只是交给cpu执行，具体什么时候执行由cpu决定

- 线程状态：新生(new)，就绪(start)，运行(cpu调用)，阻塞(sleep)，死亡(干涉或执行完毕)

  ![image-20200531181448432](C:\Users\82305\AppData\Roaming\Typora\typora-user-images\image-20200531181448432.png)

- 线程停止的方式：

  - 线程正常执行完
  - jdk中提供了destroy()和stop()方法，但是已经不使用了（不要使用！！！！！）
  - 外部干涉--》加入标志位

- yield礼让线程，将正在运行的线程暂停，运行-》就绪

- sleep，运行-》阻塞

- join 插队，合并线程，此线程执行完毕后执行其他线程，其他线程阻塞

- 优先级：调度器优先调用优先级高的线程，不意味着优先级高的线程一定先执行

- 线程：用户线程和守护线程，虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕（后台记录操作日志、监控内存使用）

- 线程同步

  - 保证数据的准确性和性能---并发控制
  - 并发：同一个对象被多个线程同时操作
  - 保证线程安全：队列（保证排队一个一个用）+锁（排他锁）---》线程的同步
  - 多线程锁机制：synchronized关键字，一个线程拿到锁后，其余线程需要等待，效率低
  - synchronized锁的是不变的对象（地址不变，内容可变）（this），是资源，在方法前加synchronized，因为数据都是在方法中操作，但是效率低下

- 避免死锁的发生：不要锁套锁

- 线程间通信（生产者消费者）

  - 管程法（使用缓冲区容器）
  - 信号灯法

- 任务定时调度：某一个有规律的时间点干某件事--》Timer（本身就是一个线程）和TimerTask（抽象类，实现了Runnable接口）

- 关键字volatile：保证数据的同步（可见性），可以避免指令重排